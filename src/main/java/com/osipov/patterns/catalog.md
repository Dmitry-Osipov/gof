# Каталог паттернов проектирования
## Abstract Factory
Предоставляет интерфейс для создания семейств, связанных между собой, или независимых объектов, конкретные классы 
которых неизвестны.
## Adapter
Преобразует интерфейс класса в некоторый другой интерфейс, ожидаемый клиентами. Обеспечивает совместную работу классов, 
которая была бы невозможна без данного паттерна из-за несовместимости интерфейсов.
## Bridge
Отделяет абстракцию от реализации, благодаря чему появляется возможность независимо изменять то и другое.
## Builder
Отделяет конструирование сложного объекта от его представления, позволяя использовать один и тот же процесс
конструирования для создания различных представлений.
## Chain of Responsibility
Можно избежать жесткой зависимости отправителя запроса от его получателя, при этом запросом начинает обрабатываться 
один из нескольких объектов. Объекты получатели связываются в цепочку, и запрос передается по цепочке, пока какой-то 
объект его не обработает.
## Command
Инкапсулирует запрос в виде объекта, позволяя тем самым параметризовывать клиентов типом запроса, устанавливать 
очередность запросов, протоколировать их и поддерживать отмену выполнения операций.
## Composite
Группирует объекты в древовидные структуры для представления иерархий типа «часть-целое». Позволяет клиентам работать 
с единичными объектами так же, как с группами объектов.
## Decorator
Динамически возлагает на объект новые функции. Декораторы применяются для расширения имеющейся функциональности и
являются гибкой альтернативой порождению подклассов.
## Facade
Предоставляет унифицированный интерфейс к множеству интерфейсов в некоторой подсистеме. Определяет интерфейс более
высокого уровня, облегчающий работу с подсистемой.
## Factory Method
Определяет интерфейс для создания объектов, при этом выбранный класс инстанцируется подклассами.
## Flyweight
Использует разделение для эффективной поддержки большого числа мелких объектов.
## Interpreter
Для заданного языка определяет представление его грамматики, а также интерпретатор предложений языка, использующий это
представление.
## Iterator
Дает возможность последовательно обойти все элементы составного объекта, не раскрывая его внутреннего представления.
## Mediator
Определяет объект, в котором инкапсулировано знание о том, как взаимодействуют объекты из некоторого множества.
Способствует уменьшению числа связей между объектами, позволяя им работать без явных ссылок друг на друга. Это, в свою
очередь, дает возможность независимо изменять схему взаимодействия.
## Memento
Позволяет, не нарушая инкапсуляции, получить и сохранить во внешней памяти внутреннее состояние объекта, чтобы позже
объект можно было восстановить точно в таком же состоянии.
## Observer
Определяет между объектами зависимость типа один-ко-многим, так что при изменении состоянии одного объекта все
зависящие от него получают извещение и автоматически обновляются.
## Prototype
Описывает виды создаваемых объектов с помощью прототипа и создает новые объекты путем его копирования.
## Proxy
Подменяет другой объект для контроля доступа к нему.
## Singleton
Гарантирует, что некоторый класс может иметь только один экземпляр, и предоставляет глобальную точку доступа к нему.
## State
Позволяет объекту варьировать свое поведение при изменении внутреннего состояния. При этом создается впечатление, что
поменялся класс объекта.
## Strategy
Определяет семейство алгоритмов, инкапсулируя их все и позволяя подставлять один вместо другого. Можно менять алгоритм
независимо от клиента, который им пользуется.
## Template Method
Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Позволяет подклассам 
переопределять шаги алгоритма, не меняя его общей структуры.
## Visitor
Представляет операцию, которую надо выполнить над элементами объекта. Позволяет определить новую операцию, не меняя
классы элементов, к которым он применяется.